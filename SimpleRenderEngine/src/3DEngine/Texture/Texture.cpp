#include "pch.h"
#include "Texture.h"
#include <Utilities/Logger.h>

namespace RenderEngine {
	Texture::Texture()
	{
	}
	// TODO: Current Texture Copy implementation only copies the highest resolution mip (level 0)
	// This implementation is fine when the hardware generates the mips because our newly created texture will do the same
	// This only fails if the mip levels contain custom data that was generated by the hardware via glGenerateMipmap(...)
	Texture::Texture(const Texture &texture) : mTextureId(0), mTextureTarget(texture.getTextureTarget()), mWidth(texture.getWidth()), mHeight(texture.getHeight()), mTextureSettings(texture.getTextureSettings()) {
		glGenTextures(1, &mTextureId);
		bind();

		glTexImage2D(mTextureTarget, 0, mTextureSettings.TextureFormat, mWidth, mHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, nullptr);
		applyTextureSettings();
		glCopyImageSubData(texture.getTextureId(), texture.getTextureTarget(), 0, 0, 0, 0, mTextureId, mTextureTarget, 0, 0, 0, 0, mWidth, mHeight, 1);

		unbind();
	}

	Texture::Texture(TextureSettings &settings) : mTextureId(0), mTextureTarget(0), mWidth(0), mHeight(0), mTextureSettings(settings) {}

	Texture::~Texture() 
	{
		glDeleteTextures(1, &mTextureId);
	}

	void Texture::applyTextureSettings() {
		// Texture wrapping
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, mTextureSettings.TextureWrapSMode);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, mTextureSettings.TextureWrapTMode);
		if (mTextureSettings.HasBorder) {
			glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, glm::value_ptr(mTextureSettings.BorderColour));
		}

		// Texture filtering
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, mTextureSettings.TextureMinificationFilterMode);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, mTextureSettings.TextureMagnificationFilterMode);

		// Mipmapping
		if (mTextureSettings.HasMips) {
			glGenerateMipmap(GL_TEXTURE_2D);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_LOD_BIAS, mTextureSettings.MipBias);
		}

		// Anisotropic filtering (TODO: Move the anistropyAmount calculation to Defs.h to avoid querying the OpenGL driver everytime)
		float maxAnisotropy;
		glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &maxAnisotropy);
		float anistropyAmount = glm::min(maxAnisotropy, mTextureSettings.TextureAnisotropyLevel);
		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, anistropyAmount);
	}

	void Texture::generate2DTexture(unsigned int width, unsigned int height, GLenum dataFormat, GLenum pixelDataType, const void *data) {
		mTextureTarget = GL_TEXTURE_2D;
		mWidth = width;
		mHeight = height;

		// If GL_NONE is specified, set the texture format to the data format
		if (mTextureSettings.TextureFormat == GL_NONE) {
			mTextureSettings.TextureFormat = dataFormat;
		}
		// Check if the texture is SRGB, if so change the texture format
		if (mTextureSettings.IsSRGB) {
			switch (dataFormat) {
			case GL_RGB: mTextureSettings.TextureFormat = GL_SRGB; break;
			case GL_RGBA: mTextureSettings.TextureFormat = GL_SRGB_ALPHA; break;
			}
		}

		glGenTextures(1, &mTextureId);
		bind();

		glTexImage2D(GL_TEXTURE_2D, 0, mTextureSettings.TextureFormat, width, height, 0, dataFormat, pixelDataType, data);
		applyTextureSettings();

		unbind();
	}

	void Texture::generateMips() {
		mTextureSettings.HasMips = true;
		if (isGenerated()) {
			bind();
			glGenerateMipmap(mTextureTarget);
		}
	}

	void Texture::bind(int unit) {
		glActiveTexture(GL_TEXTURE0 + unit);
		glBindTexture(mTextureTarget, mTextureId);
	}

	void Texture::unbind() {
		glBindTexture(mTextureTarget, 0);
	}

	void Texture::setTextureWrapS(GLenum textureWrapMode) {
		if (mTextureSettings.TextureWrapSMode == textureWrapMode)
			return;

		mTextureSettings.TextureWrapSMode = textureWrapMode;
		if (isGenerated()) {
			glTexParameteri(mTextureTarget, GL_TEXTURE_WRAP_S, mTextureSettings.TextureWrapSMode);
		}
	}

	void Texture::setTextureWrapT(GLenum textureWrapMode) {
		if (mTextureSettings.TextureWrapTMode == textureWrapMode)
			return;

		mTextureSettings.TextureWrapTMode = textureWrapMode;
		if (isGenerated()) {
			glTexParameteri(mTextureTarget, GL_TEXTURE_WRAP_T, mTextureSettings.TextureWrapTMode);
		}
	}

	void Texture::setHasBorder(bool hasBorder) {
		if (mTextureSettings.HasBorder == hasBorder)
			return;

		mTextureSettings.HasBorder = hasBorder;
		if (isGenerated()) {
			glTexParameterfv(mTextureTarget, GL_TEXTURE_BORDER_COLOR, glm::value_ptr(mTextureSettings.BorderColour));
		}
	}

	void Texture::setBorderColour(glm::vec4 &borderColour) {
		if (mTextureSettings.BorderColour == borderColour || mTextureSettings.HasBorder == false)
			return;

		mTextureSettings.BorderColour = borderColour;
		if (isGenerated()) {
			glTexParameterfv(mTextureTarget, GL_TEXTURE_BORDER_COLOR, glm::value_ptr(mTextureSettings.BorderColour));
		}
	}

	void Texture::setTextureMinFilter(GLenum textureFilterMode) {
		if (mTextureSettings.TextureMinificationFilterMode == textureFilterMode)
			return;

		mTextureSettings.TextureMinificationFilterMode = textureFilterMode;
		if (isGenerated()) {
			glTexParameteri(mTextureTarget, GL_TEXTURE_MIN_FILTER, mTextureSettings.TextureMinificationFilterMode);
		}
	}

	void Texture::setTextureMagFilter(GLenum textureFilterMode) {
		// If mag filter mode exceeds GL_Linear (bilinear) report an error because it is useless to perform more expensive filtering with magnification
		if (textureFilterMode > GL_LINEAR)
			Logger::getInstance().warning("logged_files/textures.txt", "Texture Filter Tuning", "Texture's magnification filter exceeded bilinear filtering which won't result in any visual improvements and will just cost more");

		if (mTextureSettings.TextureMagnificationFilterMode == textureFilterMode)
			return;

		mTextureSettings.TextureMagnificationFilterMode = textureFilterMode;
		if (isGenerated()) {
			glTexParameteri(mTextureTarget, GL_TEXTURE_MAG_FILTER, mTextureSettings.TextureMagnificationFilterMode);
		}
	}

	void Texture::setAnisotropicFilteringMode(float textureAnisotropyLevel) {
		if (mTextureSettings.TextureAnisotropyLevel == textureAnisotropyLevel)
			return;

		mTextureSettings.TextureAnisotropyLevel = textureAnisotropyLevel;
		if (isGenerated()) {
			float maxAnisotropy;
			glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &maxAnisotropy);
			float anistropyAmount = glm::min(maxAnisotropy, mTextureSettings.TextureAnisotropyLevel);
			glTexParameterf(mTextureTarget, GL_TEXTURE_MAX_ANISOTROPY_EXT, anistropyAmount);
		}
	}

	void Texture::setMipBias(int mipBias) {
		if (mTextureSettings.MipBias == mipBias)
			return;

		mTextureSettings.MipBias = mipBias;
		if (isGenerated()) {
			glTexParameteri(mTextureTarget, GL_TEXTURE_LOD_BIAS, mTextureSettings.MipBias);
		}
	}

	void Texture::setHasMips(bool HasMips) {
		if (mTextureSettings.HasMips == HasMips)
			return;

		mTextureSettings.HasMips = HasMips;
		if (isGenerated() && HasMips == true) {
			glGenerateMipmap(mTextureTarget);
		}
	}

}
